"use strict";(self.webpackChunkreact_native_reanimated_docs=self.webpackChunkreact_native_reanimated_docs||[]).push([[554],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),c=r,f=d["".concat(l,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={id:"measure",title:"measure",sidebar_label:"measure"},o=void 0,s={unversionedId:"api/nativeMethods/measure",id:"api/nativeMethods/measure",title:"measure",description:"Determines the location on screen, width, and height of the given view. Note that these measurements are not available until after the rendering has been completed in native. If you need the measurements as soon as possible, consider using onLayout instead.",source:"@site/docs/api/nativeMethods/measure.md",sourceDirName:"api/nativeMethods",slug:"/api/nativeMethods/measure",permalink:"/react-native-reanimated/docs/next/api/nativeMethods/measure",draft:!1,tags:[],version:"current",frontMatter:{id:"measure",title:"measure",sidebar_label:"measure"},sidebar:"docs",previous:{title:"Layout Transitions",permalink:"/react-native-reanimated/docs/next/api/LayoutAnimations/layoutTransitions"},next:{title:"scrollTo",permalink:"/react-native-reanimated/docs/next/api/nativeMethods/scrollTo"}},l={},u=[{value:"Arguments",id:"arguments",level:3},{value:"animatedRef",id:"animatedref",level:4},{value:"Returns",id:"returns",level:3},{value:"Example",id:"example",level:3}],p={toc:u};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Determines the location on screen, width, and height of the given view. Note that these measurements are not available until after the rendering has been completed in native. If you need the measurements as soon as possible, consider using ",(0,r.kt)("a",{parentName:"p",href:"https://reactnative.dev/docs/view#onlayout"},(0,r.kt)("inlineCode",{parentName:"a"},"onLayout"))," instead."),(0,r.kt)("p",null,"This function is implemented on native platforms only. On web, it's sufficient to use a standard version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"measure")," which is available on most of the default components provided by React Native (it's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/65975dd28de0a7b8b8c4eef6479bf7eee5fcfb93/Libraries/Renderer/shims/ReactNativeTypes.js#L105"},"here"),"). In such a case it should be invoked in the following way (note it's asynchronous so if you want to make it synchronous you should use ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const aref = useAnimatedRef();\nnew Promise((resolve, reject) => {\n  if (aref && aref.current) {\n    aref.current.measure((x, y, width, height, pageX, pageY) => {\n      resolve({ x, y, width, height, pageX, pageY });\n    });\n  } else {\n    reject(new Error('measure: animated ref not ready'));\n  }\n});\n")),(0,r.kt)("p",null,"If you call ",(0,r.kt)("inlineCode",{parentName:"p"},"measure()")," inside ",(0,r.kt)("a",{parentName:"p",href:"../hooks/useAnimatedStyle"},(0,r.kt)("inlineCode",{parentName:"a"},"useAnimatedStyle()")),"\nyou may get a warning that ",(0,r.kt)("inlineCode",{parentName:"p"},"measure()")," was called from the wrong thread. This\nis safe to ignore, but if you don't want this error to appear then wrap the call\nlike this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"if (_WORKLET) {\n  const measure = measure(animatedRef);\n  // ...\n}\n")),(0,r.kt)("h3",{id:"arguments"},"Arguments"),(0,r.kt)("h4",{id:"animatedref"},"animatedRef"),(0,r.kt)("p",null,"The product of ",(0,r.kt)("a",{parentName:"p",href:"../hooks/useAnimatedRef"},(0,r.kt)("inlineCode",{parentName:"a"},"useAnimatedRef"))," which is Reanimated's extension of a standard React ref (delivers the view tag on the UI thread)."),(0,r.kt)("h3",{id:"returns"},"Returns"),(0,r.kt)("p",null,"An object of type ",(0,r.kt)("inlineCode",{parentName:"p"},"MeasuredDimensions"),", which contains these fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"y")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"width")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pageX")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pageY"))),(0,r.kt)("p",null,"If the measurement could not be performed, returns ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"measure()")," only on rendered components. For example, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"measure()")," on an offscreen ",(0,r.kt)("inlineCode",{parentName:"p"},"FlatList")," item will return ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),". It is therefore a good practice to perform a ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"-check before using the response."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const Comp = () => {\n  const aref = useAnimatedRef();\n\n  useDerivedValue(() => {\n    const measured = measure(aref);\n    if (measured !== null) {\n      const { x, y, width, height, pageX, pageY } = measured;\n      console.log({ x, y, width, height, pageX, pageY });\n    } else {\n      console.warn('measure: could not measure view');\n    }\n  });\n\n  return <View ref={aref} />;\n};\n")))}m.isMDXComponent=!0}}]);